<div align="center" dir="rtl">

# 04 - الميزات الأساسية (Key Features)

## الغوص العميق في الميزات

<div align="center">
<img width="600" src="https://raw.githubusercontent.com/andreasbm/readme/master/assets/lines/aqua.png"/>
</div>

## مقدمة

توفر هذه الوثيقة توثيقاً مفصلاً لكل ميزة رئيسية في SourceShan. لكل ميزة، سنغطي قصة المستخدم، التنفيذ التقني، التحديات، والنتائج.

<div align="center">
<img width="600" src="https://raw.githubusercontent.com/andreasbm/readme/master/assets/lines/aqua.png"/>
</div>

## الميزة 1: مصادقة قلعة الحافة (Edge Fortress Authentication)

### نظرة عامة

مصادقة تعمل عند الحافة (CDN level) قبل وصول الطلبات إلى وقت تشغيل Node.js. تُرفض الرموز غير الصالحة فوراً بتكلفة حوسبة صفرية.

### قصة المستخدم

**بصفتي** مدير المنصة  
**أحتاج إلى** ضمان وصول المستخدمين المصادق عليهم فقط للموارد المحمية  
**بحيث** تظل بيانات العميل آمنة ولا تُهدر موارد الخادم على طلبات غير صالحة

### التنفيذ التقني

#### المعمارية

```
┌─────────────────────────────────────────────────────────────────┐
│                         الطلب (REQUEST)                           │
│                            │                                     │
│                            ▼                                     │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │                   Edge Middleware                         │   │
│  │                                                          │   │
│  │  ┌────────────────┐    ┌────────────────┐               │   │
│  │  │ استخراج التوكن │───►│ التحقق (JOSE)  │               │   │
│  │  └────────────────┘    └───────┬────────┘               │   │
│  │                               │                          │   │
│  │            ┌──────────────────┼──────────────────┐       │   │
│  │            ▼                  ▼                  ▼       │   │
│  │     ┌───────────┐     ┌───────────┐     ┌───────────┐   │   │
│  │     │   توكن    │     │   توكن    │     │   توكن    │   │   │
│  │     │   صالح    │     │   منتهي   │     │ غير صالح  │   │   │
│  │     └─────┬─────┘     └─────┬─────┘     └─────┬─────┘   │   │
│  │           │                 │                 │          │   │
│  │           │                 ▼                 │          │   │
│  │           │         ┌───────────────┐         │          │   │
│  │           │         │ محاولة تحديث  │         │          │   │
│  │           │         │    التوكن     │         │          │   │
│  │           │         └───────┬───────┘         │          │   │
│  │           │                 │                 │          │   │
│  │           │      ┌──────────┼──────────┐     │          │   │
│  │           │      ▼          ▼          │     │          │   │
│  │           │   ┌──────┐ ┌──────────┐   │     │          │   │
│  │           │   │ تم   │ │ فشل      │   │     │          │   │
│  │           │   │      │ │ التحديث  │   │     │          │   │
│  │           │   └───┬──┘ └────┬─────┘   │     │          │   │
│  │           │       │         │         │     │          │   │
│  │           ▼       ▼         ▼         ▼     ▼          │   │
│  │     ┌───────────────┐ ┌────────────────────────┐        │   │
│  │     │   متابعة      │ │   توجيه للدخول         │        │   │
│  │     │   للخادم      │ │   أو استجابة 401       │        │   │
│  │     └───────────────┘ └────────────────────────┘        │   │
│  └──────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
```

#### التقنيات الرئيسية

| التقنية | الغرض |
|------------|---------|
| **JOSE** | التحقق من JWT في Edge Runtime |
| **Next.js Middleware** | اعتراض الطلبات عند الحافة |
| **HttpOnly Cookies** | تخزين آمن للتوكن |

#### تدفق البيانات

1. يصل الطلب إلى Edge
2. يستخرج Middleware `accessToken` و `refreshToken` من الكوكيز
3. محاولة التحقق من access token بـ JOSE
4. إذا صالح ← تابع لمسار API
5. إذا منتهي ← حاول التحديث باستخدام refresh token
6. إذا نجح التحديث ← تعيين access token جديد، ومتابعة
7. إذا فشل الكل ← توجيه للدخول أو إرجاع 401

### التحديات

**التحدي:** jsonwebtoken لا تعمل في Edge Runtime.  
**الحل:** استخدام مكتبة JOSE المصممة لبيئات JavaScript الحديثة.

**التحدي:** الحاجة لتحديث الرموز دون تدخل المستخدم.  
**الحل:** يتحقق Middleware من رمز التحديث عند انتهاء صلاحية رمز الوصول ويصدر رمزاً جديداً تلقائياً.

### الأثر

| المقياس | القيمة |
|--------|-------|
| **تكلفة الطلب غير الصالح** | صفر حوسبة (مرفوض عند Edge) |
| **زمن استجابة المصادقة** | أقل من مللي ثانية (شبكة Edge) |
| **وضع الأمان** | دفاع من 5 طبقات يبدأ عند Edge |

<div align="center">
<img width="600" src="https://raw.githubusercontent.com/andreasbm/readme/master/assets/lines/aqua.png"/>
</div>

## الميزة 2: نظام تدوير التوكن المزدوج (Dual-Token Rotation)

### نظرة عامة

معمارية أمان تستخدم رموز وصول قصيرة العمر (15 دقيقة) للأمان ورموز تحديث طويلة العمر (7 أيام) لتجربة المستخدم، مع تدوير صامت تلقائي.

### قصة المستخدم

**بصفتي** مستخدماً  
**أحتاج إلى** البقاء مسجلاً للدخول عبر الجلسات دون إعادة مصادقة مستمرة  
**بحيث** لا ينقطع سير عملي مع الحفاظ على الأمان

### التنفيذ التقني

#### معمارية التوكن

```
┌─────────────────────────────────────────────────────────────────┐
│                     دورة حياة التوكن                             │
│                                                                  │
│  LOGIN                        15 DAKIKA                          │
│    │                              │                               │
│    ▼                              ▼                               │
│  ┌────────────────┐         ┌────────────────┐                   │
│  │ Access Token   │────────►│ Access Token   │─ ─ ─ ┐            │
│  │ Created        │         │ Expires        │      │            │
│  └────────────────┘         └───────┬────────┘      │            │
│                                     │               │            │
│                              ┌──────┴──────┐        │            │
│                              ▼             ▼        │            │
│                        ┌──────────┐  ┌──────────┐   │            │
│                        │ Refresh  │  │  Force   │   │            │
│                        │ (Silent) │  │  Login   │◄─ ┘            │
│                        └────┬─────┘  └──────────┘  (if no        │
│                             │                       refresh)     │
│                             ▼                                    │
│                      ┌────────────────┐                          │
│                      │ New Access     │                          │
│                      │ Token Created  │                          │
│                      └────────────────┘                          │
│                                                                  │
│  ┌────────────────┐                      ┌────────────────┐      │
│  │ Refresh Token  │─────────────────────►│ Refresh Token  │      │
│  │ Created        │       7 AYYAM        │ Expires        │      │
│  └────────────────┘                      └───────┬────────┘      │
│                                                  │               │
│                                                  ▼               │
│                                          ┌────────────────┐      │
│                                          │ Must Re-Login  │      │
│                                          └────────────────┘      │
└─────────────────────────────────────────────────────────────────┘
```

#### حمولة التوكن (Payload)

```typescript
interface TokenPayload {
  username: string;
  role: 'admin' | 'client';
  id: string;
  portfolioCount: number;
  firstPortfolioId?: string;
}
```

#### تكوين الكوكيز

| الكوكيز | HttpOnly | Secure | SameSite | MaxAge |
|--------|----------|--------|----------|--------|
| accessToken | نعم | نعم (prod) | None (prod) / Lax (dev) | 15 دقيقة |
| refreshToken | نعم | نعم (prod) | None (prod) / Lax (dev) | 7 أيام |

### التحديات

**التحدي:** الحفاظ على الجلسات حية دون مخاطر أمنية.  
**الحل:** رموز وصول لمدة 15 دقيقة تحد من النافذة في حال سرقة الرمز، بينما توفر رموز التحديث لمدة 7 أيام تجربة سلسة.

**التحدي:** تحديث التوكن يجب أن يكون غير مرئي للمستخدمين.  
**الحل:** Middleware يعالج التحديث تلقائياً؛ المستخدمون لا يرون مطالبات مصادقة أبداً أثناء الجلسات النشطة.

### الأثر

| النتيجة | الوصف |
|---------|-------------|
| **استمرارية الجلسة** | المستخدمون يظلون مسجلين لمدة 7 أيام |
| **نافذة الهجوم** | محدودة بـ 15 دقيقة للرموز المسروقة |
| **احتكاك المستخدم** | صفر انقطاعات للدخول أثناء الاستخدام النشط |

<div align="center">
<img width="600" src="https://raw.githubusercontent.com/andreasbm/readme/master/assets/lines/aqua.png"/>
</div>

## الميزة 3: محرك نماذج مدفوع بالمخطط (Schema-Driven Form Engine)

### نظرة عامة

نظام توليد نماذج ديناميكي يقرأ مخططات JSON ويعرض مكونات النموذج المناسبة تلقائياً. إضافة حقول جديدة للمخطط تحدث واجهة المحرر تلقائياً.

### قصة المستخدم

**بصفتي** مطوراً  
**أحتاج إلى** إضافة حقول محفظة جديدة دون كتابة كود للمحرر  
**بحيث** أستطيع التكرار بسرعة وتقليل الأخطاء

### التنفيذ التقني

#### هرمية المكونات

```
┌────────────────────────────────────────────────────────────────┐
│                        MainEditor                               │
│                            │                                    │
│                            ▼                                    │
│                     ┌─────────────┐                             │
│                     │ DynamicForm │                             │
│                     └──────┬──────┘                             │
│                            │                                    │
│              ┌─────────────┼─────────────┐                      │
│              ▼             ▼             ▼                      │
│       ┌─────────────┐ ┌─────────────┐ ┌─────────────┐          │
│       │FieldRenderer│ │FieldRenderer│ │FieldRenderer│          │
│       └──────┬──────┘ └──────┬──────┘ └──────┬──────┘          │
│              │               │               │                  │
│    ┌─────────┴────┐    ┌─────┴─────┐   ┌─────┴─────┐           │
│    ▼              ▼    ▼           ▼   ▼           ▼           │
│ ┌──────┐    ┌──────────┐ ┌──────────┐ ┌──────────────────┐     │
│ │Input │    │Bilingual │ │ImageInput│ │DetailedContent   │     │
│ │      │    │TextField │ │          │ │Editor            │     │
│ └──────┘    └──────────┘ └──────────┘ └──────────────────┘     │
└────────────────────────────────────────────────────────────────┘
```

#### تعيين المخطط للمكون (Mapping)

| نوع المخطط | x-format | المكون المعروض |
|-------------|----------|-------------------|
| `string` | - | إدخال نصي |
| `object` | - | Bilingual TextField (إذا كان يحوي `ar`/`en`) |
| `array` | `detailed-content` | DetailedContentEditor |
| `array` | `simple-list` | StringArrayEditor |
| `array` | `bilingual-list` | BilingualListEditor |
| `string` | `image` | ImageInput |

### التحديات

**التحدي:** مخططات متداخلة معقدة مع أنواع حقول متعددة.  
**الحل:** `FieldRenderer` تكراري يرسل للمكونات المتخصصة.

**التحدي:** رفع الصور يحتاج لمرحلة انتظار قبل الحفظ.  
**الحل:** `PendingMediaContext` يدير الرفوعات المعلقة بشكل منفصل عن حالة النموذج.

### الأثر

| المقياس | قبل | بعد |
|--------|--------|-------|
| **وقت إضافة حقل جديد** | ساعات (كود + نشر) | دقائق (تحديث مخطط) |
| **تغييرات الكود لحقل جديد** | ملفات متعددة | صفر |
| **خطر الأخطاء** | عالي (واجهة يدوية) | منخفض (محرك مختبر) |

<div align="center">
<img width="600" src="https://raw.githubusercontent.com/andreasbm/readme/master/assets/lines/aqua.png"/>
</div>

## الميزة 4: نظام التزام GitHub الدفعي (Batch Commit System)

### نظرة عامة

عمليات ذرية متعددة الملفات باستخدام Git Trees API. كل التغييرات (إنشاء، تحديث، حذف) تحدث في التزام (commit) واحد.

### قصة المستخدم

**بصفتي** مستخدماً  
**أحتاج إلى** حفظ تغييرات المحفظة ذرياً  
**بحيث** لا تترك بياناتي في حالة غير متسقة أبداً

### التنفيذ التقني

#### التقليدي vs. الدفعي (Batch)

```
BATCH (Git Trees API):
┌─────────────────────────────────────────────────────────────────┐
│  بناء الشجرة بكل التغييرات ───────────► التزام واحد (Single Commit) │
│                                                                  │
│  النتيجة: 1 التزام ذري                                          │
│  الضمان: الكل ينجح أو لا شيء                                     │
└─────────────────────────────────────────────────────────────────┘
```

#### تدفق Git Trees API

```
1. الحصول على Commit SHA الحالي
2. الحصول على Tree SHA الحالي
3. إنشاء Blobs للمحتوى الجديد
4. إنشاء شجرة جديدة بالتغييرات
5. إنشاء التزام بالشجرة الجديدة
6. تحديث مرجع الفرع
✅ تم
```

### التحديات

**التحدي:** حذف الملفات يتطلب إعادة بناء كاملة للشجرة.  
**الحل:** المشي التكراري في الشجرة، استبعاد الملفات المحددة للحذف، ثم إعادة البناء.

**التحدي:** الصور الكبيرة لا ينبغي أن تكون base64 في الطلب.  
**الحل:** رفع الصور مسبقاً كـ Blobs، والإشارة إليها بـ SHA في الشجرة.

### الأثر

| الجانب | قبل | بعد |
|--------|--------|-------|
| **التزامات لكل حفظ** | N (واحد لكل ملف) | 1 |
| **اتساق البيانات** | في خطر | مضمون |
| **استدعاءات API** | O(n) التزامات | O(n) blobs + 3 التزامات |
| **التراجع (Rollback)** | معقد | استرجاع git واحد |

<div align="center">
<img width="600" src="https://raw.githubusercontent.com/andreasbm/readme/master/assets/lines/aqua.png"/>
</div>

## الميزة 5: سياق الوسائط المعلقة (Pending Media Context)

### نظرة عامة

إدارة حالة من جانب العميل لرفع الصور وحذفها مرحلياً قبل الالتزام إلى GitHub.

### قصة المستخدم

**بصفتي** مستخدماً  
**أحتاج إلى** معاينة الصور قبل الحفظ  
**بحيث** أتحقق من تغييراتي قبل أن تصبح دائمة

### التنفيذ التقني

#### هيكل الحالة

```typescript
interface PendingMediaState {
  pendingImages: Map<string, {
    file: File;
    previewUrl: string;  // blob: URL
    targetPath: string;  // where it will be uploaded
  }>;
  deletedPaths: Set<string>;  // paths to delete on save
}
```

### التحديات

**التحدي:** يجب إبطال Blob URLs لمنع تسرب الذاكرة.  
**الحل:** السياق يتتبع كل Blob URLs ويبطلها عند الحفظ أو المسح.

**التحدي:** الصور المحذوفة يجب إزالتها من GitHub.  
**الحل:** مجموعة `deletedPaths` تتتبع عمليات الإزالة؛ الحفظ الدفعي يتضمن عمليات DELETE.

### الأثر

| الميزة | الفائدة |
|---------|---------|
| **معاينة فورية** | المستخدمون يرون التغييرات قبل الالتزام |
| **رفع دفعي** | طلب واحد فعال لكل الصور |
| **دعم التراجع** | مسح الحالة المعلقة = تراجع عن التغييرات |
| **سلامة الذاكرة** | تنظيف Blob URLs بشكل صحيح |

<div align="center">
<img width="600" src="https://raw.githubusercontent.com/andreasbm/readme/master/assets/lines/aqua.png"/>
</div>

## الميزة 6: تجميع الاتصالات العالمي (Global Connection Pooling)

### نظرة عامة

نمط Singleton لاتصالات MongoDB ينجو من بدايات Lambda الباردة ويمنع استنفاد الاتصالات.

### قصة المستخدم

**بصفتي** مشغل نظام  
**أحتاج إلى** منع استنفاد اتصالات قاعدة البيانات  
**بحيث** يظل النظام مستقراً تحت الحمل

### التنفيذ التقني

#### المشكلة

```
بدون تجميع:
┌─────────────────────────────────────────────────────────────────┐
│  طلب 1 → Lambda Instance A → اتصال MongoDB جديد                 │
│  طلب 2 → Lambda Instance B → اتصال MongoDB جديد                 │
│  طلب 3 → Lambda Instance C → اتصال MongoDB جديد                 │
│  طلب 4 → Lambda Instance A → اتصال MongoDB جديد (!)             │
│                                                                  │
│  النتيجة: تتضاعف الاتصالات بسرعة                                 │
│  خطأ: "Too Many Connections"                                    │
└─────────────────────────────────────────────────────────────────┘

مع تجميع:
┌─────────────────────────────────────────────────────────────────┐
│  طلب 1 → Lambda Instance A → اتصال MongoDB جديد                 │
│  طلب 2 → Lambda Instance B → اتصال MongoDB جديد                 │
│  طلب 3 → Lambda Instance C → اتصال MongoDB جديد                 │
│  طلب 4 → Lambda Instance A → إعادة استخدام الاتصال الموجود ✓    │
│                                                                  │
│  النتيجة: اتصال واحد لكل مثيل Lambda                             │
│  مستقر: الاتصالات محدودة بتزامن Lambda                           │
└─────────────────────────────────────────────────────────────────┘
```

### الأثر

| المقياس | بدون تجميع | مع تجميع |
|--------|----------------|--------------|
| **اتصالات/مثيل** | العديد (لكل طلب) | 1 |
| **أخطاء الاتصال** | متكررة تحت الحمل | لا يوجد |
| **عقوبة البدء البارد** | كل طلب | أول طلب فقط |

<div align="center">
<img width="600" src="https://raw.githubusercontent.com/andreasbm/readme/master/assets/lines/aqua.png"/>
</div>

## ملخص

تعمل هذه الميزات معاً لإنشاء نظام آمن، فعال، وسهل الاستخدام:

| الميزة | الفائدة الأساسية |
|---------|----------------|
| مصادقة الحافة | رفض الطلبات غير الصالحة بتكلفة صفرية |
| تدوير ثنائي للتوكن | أمان دون احتكاك UX |
| نماذج مدفوعة بالمخطط | صفر كود للحقول الجديدة |
| التزامات دفعية | عمليات بيانات ذرية |
| وسائط معلقة | معاينة قبل الالتزام |
| تجميع الاتصالات | استقرار Serverless |

<div align="center">
<img width="600" src="https://raw.githubusercontent.com/andreasbm/readme/master/assets/lines/aqua.png"/>
</div>

<div align="center">

[![Prev](https://img.shields.io/badge/%E2%86%90_%D9%85%D8%B9%D9%85%D8%A7%D8%B1%D9%8A%D8%A9_%D8%A7%D9%84%D8%AD%D9%84-5042a5?style=for-the-badge)](03-solution-architecture.md) [![Next](https://img.shields.io/badge/Next_%E2%86%92_%D8%A7%D9%84%D9%82%D8%B1%D8%A7%D8%B1%D8%A7%D8%AA_%D8%A7%D9%84%D8%AA%D9%82%D9%86%D9%8A%D8%A9-4a45ea?style=for-the-badge)](05-technical-decisions.md)

</div>

</div>