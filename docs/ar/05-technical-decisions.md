<div align="center" dir="rtl">

# 05 - القرارات التقنية (Technical Decisions)

## سجلات القرارات المعمارية (Architecture Decision Records)

<div align="center">
<img width="600" src="https://raw.githubusercontent.com/andreasbm/readme/master/assets/lines/aqua.png"/>
</div>

## مقدمة

توثق هذه الوثيقة القرارات التقنية الرئيسية بتنسيق ADR (سجل القرار المعماري). يتضمن كل قرار السياق، الخيارات التي تم النظر فيها، القرار النهائي، والعواقب.

<div align="center">
<img width="600" src="https://raw.githubusercontent.com/andreasbm/readme/master/assets/lines/aqua.png"/>
</div>

## القرار 1: المصادقة أولاً عند الحافة باستخدام JOSE

### الحالة
**مقبول** ✅

### السياق

المصادقة هي أساس نموذج الأمان. الطرق التقليدية تتحقق من الرموز في طبقة التطبيق (وقت تشغيل Node.js)، مما يعني:
- كل طلب، صالحاً كان أم لا، يشغل Lambda
- الرموز غير الصالحة تستهلك موارد حوسبة
- زمن استجابة المصادقة مرتبط بأوقات البدء البارد (Cold starts)

توفر Vercel برمجيات وسيطة للحافة (Edge Middleware) تعمل على مستوى CDN قبل الوصول للتطبيق.

### الخيارات التي تم النظر فيها

#### الخيار أ: حماية المسار التقليدية
- استخدام `getServerSideProps` أو فحوصات مسار API في Next.js
- **الإيجابيات:** نمط بسيط ومألوف
- **السلبيات:** كل طلب يصل لـ Node.js، تكلفة حوسبة للطلبات غير الصالحة

#### الخيار ب: NextAuth.js
- استخدام NextAuth مع استراتيجية JWT
- **الإيجابيات:** كامل الميزات، موثق جيداً
- **السلبيات:** تبعية ثقيلة، دعم Middleware كان محدوداً وقتها، تحكم أقل

#### الخيار ج: Edge Middleware مخصص مع JOSE
- التحقق من JWTs عند الحافة باستخدام مكتبة JOSE
- **الإيجابيات:** صفر حوسبة للرموز غير الصالحة، تحكم كامل، خفيف الوزن
- **السلبيات:** كود مخصص أكثر، الحاجة لمكتبتي JWT (JOSE للحافة، jsonwebtoken لـ Node.js)

### القرار

**الخيار ج: Edge Middleware مخصص مع JOSE**

فوائد التحكم والأداء تفوقت على التعقيد الإضافي. تُرفض الرموز غير الصالحة الآن عند مستوى CDN بصفر حوسبة خادم.

### العواقب

**إيجابية:**
- رفض الطلبات غير الصالحة عند الحافة (صفر تكلفة حوسبة)
- أوقات استجابة أسرع للطلبات الصالحة
- تحكم كامل في هيكل التوكن ومنطق التحديث

**سلبية:**
- يجب صيانة مكتبتي JWT (JOSE للحافة، jsonwebtoken لتوقيع Node.js)
- الكود المخصص يعني مسؤولية صيانة أكبر
- الحاجة للتعامل مع قيود Edge Runtime

**المخاطر والتخفيف:**
- الخطر: تحديثات JOSE قد تكسر التوافق
- التخفيف: تثبيت الإصدارات، اختبار شامل

<div align="center">
<img width="600" src="https://raw.githubusercontent.com/andreasbm/readme/master/assets/lines/aqua.png"/>
</div>

## القرار 2: استراتيجية المصادقة ثنائية التوكن

### الحالة
**مقبول** ✅

### السياق

تحتاج إدارة الجلسة للموازنة بين:
- **الأمان:** الرموز قصيرة العمر تقلل الضرر من السرقة
- **تجربة المستخدم:** أعمار الجلسات الطويلة تمنع إعادة المصادقة المستمرة
- **البساطة:** أنواع رموز أقل تعني تنفيذاً أبسط

### الخيارات التي تم النظر فيها

#### الخيار أ: توكن واحد طويل العمر
- JWT واحد بصلاحية 7 أيام
- **الإيجابيات:** تنفيذ بسيط
- **السلبيات:** إذا سرق، يملك المهاجم وصولاً لمدة 7 أيام

#### الخيار ب: توكن قصير العمر + جلسات قاعدة بيانات
- JWT مدته 15 دقيقة مع تخزين جلسة من جانب الخادم
- **الإيجابيات:** إمكانية الإبطال الفوري
- **السلبيات:** بحث في قاعدة البيانات مع كل طلب، تعقيد

#### الخيار ج: توكن مزدوج (Access + Refresh)
- رمز وصول لمدة 15 دقيقة + رمز تحديث لمدة 7 أيام
- **الإيجابيات:** نافذة هجوم قصيرة، تجربة مستخدم جيدة، لا بحث في قاعدة البيانات لمعظم الطلبات
- **السلبيات:** إدارة توكن أكثر تعقيداً

### القرار

**الخيار ج: استراتيجية التوكن المزدوج**

يوفر هذا النهج أفضل توازن بين الأمان وتجربة المستخدم. يحد رمز الوصول (15 دقيقة) من التعرض للخطر بينما يمكن رمز التحديث (7 أيام) من جلسات سلسة.

### العواقب

**إيجابية:**
- نافذة الهجوم محدودة بـ 15 دقيقة لرموز الوصول المسروقة
- المستخدمون يظلون مسجلين لمدة 7 أيام دون احتكاك
- لا حاجة للبحث في قاعدة البيانات لمعظم الطلبات المصادق عليها

**سلبية:**
- رمزان للإدارة (إصدار، تخزين، تحديث)
- منطق التحديث الصامت يضيف تعقيداً
- إدارة كوكيز أكثر

**تفاصيل التنفيذ:**
- كلا الرمزين مخزنان كـ HttpOnly cookies
- Middleware يعالج التحديث الصامت
- نقطة نهاية التحديث تتحقق من رمز التحديث وتصدر رمز وصول جديد

<div align="center">
<img width="600" src="https://raw.githubusercontent.com/andreasbm/readme/master/assets/lines/aqua.png"/>
</div>

## القرار 3: GitHub كمخزن للمحتوى

### الحالة
**مقبول** ✅

### السياق

يحتاج محتوى المحفظة (مشاريع، صور، بيانات JSON) لتخزين دائم. الخيارات تشمل:
- قاعدة بيانات تقليدية (MongoDB, PostgreSQL)
- تخزين سحابي (S3, Cloudflare R2)
- مستودعات Git

محافظ العملاء منشورة بالفعل على Vercel من مستودعات GitHub.

### الخيارات التي تم النظر فيها

#### الخيار أ: MongoDB لكل شيء
- تخزين المحتوى كمستندات في MongoDB
- **الإيجابيات:** مخزن بيانات واحد، استعلام مألوف
- **السلبيات:** لا سجل إصدارات، الصور تحتاج لتخزين منفصل

#### الخيار ب: S3 للمحتوى
- ملفات JSON وصور في S3
- **الإيجابيات:** قابل للتوسع، تخزين رخيص
- **السلبيات:** لا سجل إصدارات، يتطلب مشغل نشر منفصل

#### الخيار ج: مستودعات GitHub
- ملفات JSON والصور في مستودعات GitHub
- **الإيجابيات:** تحكم في الإصدار، نشر تلقائي من Vercel عند الدفع، مصدر حقيقة واحد
- **السلبيات:** تعقيد API GitHub، حدود المعدل (Rate limits)

### القرار

**الخيار ج: مستودعات GitHub**

المحافظ تعيش بالفعل في مستودعات GitHub. استخدام GitHub كمخزن للمحتوى يعني:
- مصدر حقيقة واحد (لا مشاكل مزامنة)
- سجل إصدارات مجاني
- نشر تلقائي للمحفظة عند الالتزام (Commit)

### العواقب

**إيجابية:**
- سجل إصدارات مجاني (تاريخ Git)
- نشر تلقائي للمحفظة (Vercel يراقب المستودع)
- التراجع (Rollback) بسيط (git revert)
- لا تكاليف تخزين إضافية

**سلبية:**
- API GitHub معقدة (خاصة للعمليات الدفعية)
- حدود المعدل (5000 طلب/ساعة للتطبيقات)
- زمن استجابة أعلى من استعلامات قاعدة البيانات المباشرة

**التخفيف:**
- التخزين المؤقت لمعرف التثبيت (Installation ID) يقلل استدعاءات API
- الالتزامات الدفعية (Batch commits) تقلل عدد الطلبات
- مراقبة حدود المعدل

<div align="center">
<img width="600" src="https://raw.githubusercontent.com/andreasbm/readme/master/assets/lines/aqua.png"/>
</div>

## القرار 4: توليد النماذج المدفوع بالمخطط (Schema-Driven)

### الحالة
**مقبول** ✅

### السياق

يحتاج المحرر لعرض نماذج لهياكل محافظ مختلفة. المحافظ لها حقول مختلفة (مشاريع، مهارات، شهادات). النهج التقليدي: بناء مكون نموذج لكل نوع حقل.

### الخيارات التي تم النظر فيها

#### الخيار أ: مكونات نماذج ثابتة
- بناء مكون React لكل نوع نموذج
- **الإيجابيات:** تحكم كامل، محسن لكل نموذج
- **السلبيات:** مكون جديد لكل حقل جديد، صيانة عالية

#### الخيار ب: استخدام مكتبة نماذج (React Hook Form + Zod)
- توليد النماذج من مخططات Zod
- **الإيجابيات:** مختبر جيداً، التحقق مضمن
- **السلبيات:** لا يزال يحتاج لتعيين المكونات، تبعية أخرى

#### الخيار ج: محرك مخصص مدفوع بالمخطط
- بناء محرك نماذج يقرأ مخططات JSON
- **الإيجابيات:** إضافة حقل = إضافة للمخطط (دون كود)، مرونة قصوى
- **السلبيات:** استثمار مبدئي، كود مخصص للصيانة

### القرار

**الخيار ج: محرك مخصص مدفوع بالمخطط**

يعطي الاستثمار المبدئي رافعة طويلة الأمد. إضافة حقول جديدة تصبح تغيير تكوين، وليس تغيير كود.

### العواقب

**إيجابية:**
- صفر تغييرات كود للحقول الجديدة
- عرض متسق عبر كل النماذج
- المخطط هو المصدر الوحيد للحقيقة

**سلبية:**
- تنفيذ مبدئي أكثر تعقيداً
- كود مخصص للصيانة
- الحالات الخاصة تحتاج لمعالجة خاصة (حقول ثنائية اللغة، كتل المحتوى)

**تفاصيل التنفيذ:**
- `FieldRenderer` يرسل بناءً على نوع المخطط
- مكونات متخصصة للأنواع المعقدة (ImageInput, DetailedContentEditor)
- امتداد `x-format` للمخطط لسلوكيات مخصصة

<div align="center">
<img width="600" src="https://raw.githubusercontent.com/andreasbm/readme/master/assets/lines/aqua.png"/>
</div>

## القرار 5: التزامات دفعية ذرية (Atomic Batch Commits) عبر Git Trees API

### الحالة
**مقبول** ✅

### السياق

غالباً ما تتضمن عمليات حفظ المحفظة ملفات متعددة:
- تحديث `data/projects.json`
- رفع صور جديدة
- حذف الصور المستبدلة

استخدام واجهة Contents API القياسية لـ GitHub يعني N استدعاءات API لـ N تغييرات. كل استدعاء هو التزام منفصل. إذا فشل واحد، تصبح البيانات غير متسقة.

### الخيارات التي تم النظر فيها

#### الخيار أ: استدعاءات Contents API متسلسلة
- التزام واحد لكل تغيير ملف
- **الإيجابيات:** API بسيطة، موثقة جيداً
- **السلبيات:** ليست ذرية، تاريخ التزام فوضوي

#### الخيار ب: GraphQL API مع طفرات متعددة
- تغييرات دفعية عبر GraphQL
- **الإيجابيات:** طلب واحد
- **السلبيات:** لا تزال غير ذرية تماماً، صياغة طفرة معقدة

#### الخيار ج: Git Trees API (مستوى منخفض)
- استخدام نقاط نهاية Blobs و Trees و Commits
- **الإيجابيات:** التزامات ذرية حقيقية، تاريخ نظيف
- **السلبيات:** تنفيذ معقد، استدعاءات API أكثر مقدماً

### القرار

**الخيار ج: Git Trees API**

الذرية الحقيقية تستحق تعقيد التنفيذ. كل التغييرات تنجح أو لا شيء.

### العواقب

**إيجابية:**
- عمليات ذرية (ضمان سلامة البيانات)
- تاريخ التزام نظيف (التزام واحد لكل حفظ)
- استدعاءات API إجمالية أقل (دفعة > متسلسل)

**سلبية:**
- تنفيذ معقد (عملية من 5 خطوات)
- الحاجة للتعامل مع إعادة بناء الشجرة للحذف
- كود أكثر للصيانة

**تفاصيل التنفيذ:**
- رفع الصور الكبيرة مسبقاً كـ Blobs
- بناء شجرة بكل التغييرات
- إنشاء التزام واحد
- تحديث المرجع ذرياً

<div align="center">
<img width="600" src="https://raw.githubusercontent.com/andreasbm/readme/master/assets/lines/aqua.png"/>
</div>

## القرار 6: نمط تجميع اتصالات MongoDB

### الحالة
**مقبول** ✅

### السياق

تعمل Vercel على Lambdas (بدون خادم). قد ينشئ كل استدعاء Lambda اتصال MongoDB جديداً. تحت الحمل، تتضاعف الاتصالات بسرعة، مما يسبب أخطاء "Too Many Connections".

### الخيارات التي تم النظر فيها

#### الخيار أ: الاتصال لكل طلب
- إنشاء اتصال في كل مسار API
- **الإيجابيات:** بسيط، معزول
- **السلبيات:** استنفاد الاتصالات، بطيء (مصافحة لكل طلب)

#### الخيار ب: تجميع الاتصالات عبر تكوين Mongoose
- تكوين إعدادات المسبح (Pool) في Mongoose
- **الإيجابيات:** ميزة مضمنة
- **السلبيات:** لا تحل مشكلة إنشاء مثيل Lambda جديد

#### الخيار ج: نمط Singleton العالمي
- تخزين الاتصال مؤقتاً في النطاق العام (Global scope)
- **الإيجابيات:** يعيد استخدام الاتصال داخل مثيل Lambda
- **السلبيات:** كود مخصص، يعتمد على سلوك Lambda

### القرار

**الخيار ج: نمط Singleton العالمي**

يستمر النطاق العام عبر الاستدعاءات داخل نفس مثيل Lambda. هذا هو النمط الموصى به لـ MongoDB بدون خادم.

### العواقب

**إيجابية:**
- اتصالات مستقرة (واحد لكل مثيل Lambda)
- طلبات أسرع (لا عبء مصافحة)
- لا استنفاد للاتصالات تحت الحمل الطبيعي

**سلبية:**
- يعتمد على سلوك النطاق العام في Lambda
- الاتصال قد يصبح قديماً (يحتاج لمنطق إعادة اتصال)
- لا يزال ينشئ اتصالاً واحداً لكل مثيل Lambda

<div align="center">
<img width="600" src="https://raw.githubusercontent.com/andreasbm/readme/master/assets/lines/aqua.png"/>
</div>

## القرار 7: Tailwind CSS v4 مع الخصائص المخصصة

### الحالة
**مقبول** ✅

### السياق

يحتاج المحرر لجمالية متميزة مع تأثيرات الزجاج (Glassmorphism)، ألوان مخصصة، وتصميم مستجيب. نظام التنسيق يحتاج ليكون:
- سريع للتكرار
- متسق عبر المكونات
- يدعم الوضع المظلم والقوالب المخصصة

### الخيارات التي تم النظر فيها

#### الخيار أ: CSS Modules
- CSS محدد النطاق لكل مكون
- **الإيجابيات:** مألوف، لا وقت تشغيل
- **السلبيات:** مطول، أصعب لمشاركة الأدوات المساعدة

#### الخيار ب: Styled-Components
- CSS-in-JS مع وقت تشغيل
- **الإيجابيات:** قوالب ديناميكية، محدد النطاق للمكون
- **السلبيات:** عبء وقت التشغيل، تعقيد SSR في Next.js

#### الخيار ج: Tailwind CSS مع الخصائص المخصصة
- CSS قائم على الأدوات مع متغيرات CSS للقوالب
- **الإيجابيات:** تكرار سريع، أدوات مساعدة أولاً، خصائص مخصصة للقوالب
- **السلبيات:** سلاسل فئات طويلة، منحنى تعلم

### القرار

**الخيار ج: Tailwind CSS مع الخصائص المخصصة**

نهج Tailwind القائم على الأدوات يسرع التطوير. تمكن خصائص CSS المخصصة القوالب (ألوان الزجاج، ألوان العلامة التجارية) دون JavaScript.

### العواقب

**إيجابية:**
- نماذج أولية وتكرار سريع
- تباعد وألوان وخطوط متسقة
- تمكين القوالب بسهولة عبر الخصائص المخصصة
- لا عبء وقت تشغيل CSS-in-JS

**سلبية:**
- سلاسل الفئات الطويلة قد تكون صعبة القراءة
- الحاجة للانضباط لاستخراج الأنماط المتكررة
- تأثيرات الزجاج تتطلب CSS مخصصاً

<div align="center">
<img width="600" src="https://raw.githubusercontent.com/andreasbm/readme/master/assets/lines/aqua.png"/>
</div>

## ملخص

تخلق هذه القرارات معمارية متماسكة:

| القرار | المقايضة | النتيجة |
|----------|-----------|---------|
| مصادقة الحافة | مكتبات JWT أكثر | رفض بتكلفة صفرية |
| توكن مزدوج | تعقيد التوكن | أمان + تجربة مستخدم |
| تخزين GitHub | تعقيد API | تحكم في الإصدار |
| مدفوع بالمخطط | استثمار مبدئي | مرونة مستقبلية |
| التزامات دفعية | عمل التنفيذ | سلامة البيانات |
| تجميع الاتصالات | حالة عالمية | استقرار Serverless |
| Tailwind + متغيرات | إطناب الفئات | تكرار سريع |

<div align="center">
<img width="600" src="https://raw.githubusercontent.com/andreasbm/readme/master/assets/lines/aqua.png"/>
</div>

<div align="center">

[![Prev: Key Features](https://img.shields.io/badge/←_Prev:_Key_Features-5042a5?style=for-the-badge)](04-key-features.md) [![Next: Challenges & Solutions](https://img.shields.io/badge/Next:_Challenges_%26_Solutions_→-4a45ea?style=for-the-badge)](06-challenges-solutions.md)

</div>
